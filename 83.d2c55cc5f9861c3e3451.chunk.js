(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{375:function(n,s,e){"use strict";e.r(s),s.default='<blockquote class="tip">\n<p>本指南继承自<a href="/guides/code-splitting">代码分离</a>。如果你尚未阅读该指南，请先行阅读。</p>\n</blockquote>\n<p>懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。</p>\n<h2 id="示例">示例<a href="#%E7%A4%BA%E4%BE%8B" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>我们在<a href="/guides/code-splitting#dynamic-imports">代码分离</a>中的例子基础上，进一步做些调整来说明这个概念。那里的代码确实会在脚本运行的时候产生一个分离的代码块 <code>lodash.bundle.js</code> ，在技术概念上“懒加载”它。问题是加载这个包并不需要用户的交互 -- 意思是每次加载页面的时候都会请求它。这样做并没有对我们有很多帮助，还会对性能产生负面影响。</p>\n<p>我们试试不同的做法。我们增加一个交互，当用户点击按钮的时候用 console 打印一些文字。但是会等到第一次交互的时候再加载那个代码块（<code>print.js</code>）。为此，我们返回到代码分离的例子中，把 <code>lodash</code> 放到主代码块中，重新运行<em>代码分离</em>中的代码 <a href="/guides/code-splitting#dynamic-imports">final <em>Dynamic Imports</em> example</a>。</p>\n<p><strong>project</strong></p>\n<pre><code class="hljs language-diff">webpack-demo\n|- package.json\n|- webpack.config.js\n|- /dist\n|- /src\n  |- index.js\n<span class="token inserted">+ |- print.js</span>\n|- /node_modules</code></pre>\n<p><strong>src/print.js</strong></p>\n<pre><code class="hljs language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'The print.js module has loaded! See the network tab in dev tools...\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Button Clicked: Here\\\'s "some text"!\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff"><span class="token inserted">+ import _ from \'lodash\';</span>\n<span class="token inserted">+</span>\n<span class="token deleted">- async function getComponent() {</span>\n<span class="token inserted">+ function component() {</span>\n    const element = document.createElement(\'div\');\n<span class="token deleted">-   const _ = await import(/* webpackChunkName: "lodash" */ \'lodash\');</span>\n<span class="token inserted">+   const button = document.createElement(\'button\');</span>\n<span class="token inserted">+   const br = document.createElement(\'br\');</span>\n\n<span class="token inserted">+   button.innerHTML = \'Click me and look at the console!\';</span>\n    element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\n<span class="token inserted">+   element.appendChild(br);</span>\n<span class="token inserted">+   element.appendChild(button);</span>\n<span class="token inserted">+</span>\n<span class="token inserted">+   // Note that because a network request is involved, some indication</span>\n<span class="token inserted">+   // of loading would need to be shown in a production-level site/app.</span>\n<span class="token inserted">+   button.onclick = e => import(/* webpackChunkName: "print" */ \'./print\').then(module => {</span>\n<span class="token inserted">+     const print = module.default;</span>\n<span class="token inserted">+</span>\n<span class="token inserted">+     print();</span>\n<span class="token inserted">+   });</span>\n\n    return element;\n  }\n\n<span class="token deleted">- getComponent().then(component => {</span>\n<span class="token deleted">-   document.body.appendChild(component);</span>\n<span class="token deleted">- });</span>\n<span class="token inserted">+ document.body.appendChild(component());</span></code></pre>\n<blockquote class="warning">\n<p>注意当调用 ES6 模块的 <code>import()</code> 方法（引入模块）时，必须指向模块的 <code>.default</code> 值，因为它才是 promise 被处理后返回的实际的 <code>module</code> 对象。</p>\n</blockquote>\n<p>现在运行 webpack 来验证一下我们的懒加载功能：</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n          Asset       Size  Chunks                    Chunk Names\nprint.bundle.js  417 bytes       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         print\nindex.bundle.js     548 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  index\n     index.html  189 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\n<span class="token punctuation">..</span>.</code></pre>\n<h2 id="框架">框架<a href="#%E6%A1%86%E6%9E%B6" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>许多框架和类库对于如何用它们自己的方式来实现（懒加载）都有自己的建议。这里有一些例子：</p>\n<ul>\n<li>React: <a href="https://reacttraining.com/react-router/web/guides/code-splitting">Code Splitting and Lazy Loading</a></li>\n<li>Vue: <a href="https://vuedose.tips/tips/dynamic-imports-in-vue-js-for-better-performance/">Dynamic Imports in Vue.js for better performance</a></li>\n<li>Angular: <a href="https://angular.io/guide/router#milestone-6-asynchronous-routing">Lazy Loading route configuration</a> and <a href="https://medium.com/@var_bin/angularjs-webpack-lazyload-bb7977f390dd">AngularJS + webpack = lazyLoad</a></li>\n</ul>\n'}}]);