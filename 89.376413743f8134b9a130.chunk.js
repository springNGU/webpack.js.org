(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{381:function(n,e,s){"use strict";s.r(e),e.default='<p><code>webpack</code> compiler 能够识别遵循 ES2015 模块语法、CommonJS 或 AMD 规范编写的模块。然而，一些 third party(第三方库) 可能会引用一些全局依赖（例如 <code>jQuery</code> 中的 <code>$</code>）。因此这些 library 也可能会创建一些需要导出的全局变量。这些 "broken modules(不符合规范的模块)" 就是 <em>shimming(预置依赖)</em> 发挥作用的地方。</p>\n<blockquote class="warning">\n<p><strong>我们不推荐使用全局依赖！</strong>webpack 背后的整个理念是使前端开发更加模块化。也就是说，需要编写具有良好的封闭性(well contained)、不依赖于隐含依赖（例如，全局变量）的彼此隔离的模块。请只在必要的时候才使用这些特性。</p>\n</blockquote>\n<p><em>shim</em> 另外一个极其有用的使用场景就是：当你希望 <a href="https://en.wikipedia.org/wiki/Polyfill_(programming)">polyfill</a> 扩展浏览器能力，来支持到更多用户时。在这种情况下，你可能只是想要将这些 polyfills 提供给需要修补(patch)的浏览器（也就是实现按需加载）。</p>\n<p>下面的文章将向我们展示这两种用例。</p>\n<blockquote class="tip">\n<p>为了方便，本指南继续沿用 <a href="/guides/getting-started">起步</a> 中的代码示例。在继续之前，请确保你已经熟悉这些配置。</p>\n</blockquote>\n<h2 id="shimming-预置全局变量">Shimming 预置全局变量<a href="#shimming-%E9%A2%84%E7%BD%AE%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>让我们开始第一个 shimming 全局变量的用例。在此之前，先看下我们的项目：</p>\n<p><strong>project</strong></p>\n<pre><code class="hljs language-diff">webpack-demo\n|- package.json\n|- webpack.config.js\n|- /dist\n|- /src\n  |- index.js\n|- /node_modules</code></pre>\n<p>还记得我们之前用过的 <code>lodash</code> 吗？出于演示目的，例如把这个应用程序中的模块依赖，改为一个全局变量依赖。要实现这些，我们需要使用 <code>ProvidePlugin</code> 插件。</p>\n<p>使用 <a href="/plugins/provide-plugin"><code>ProvidePlugin</code></a> 后，能够在 webpack 编译的每个模块中，通过访问一个变量来获取一个 package。如果 webpack 看到模块中用到这个变量，它将在最终 bundle 中引入给定的 package。让我们先移除 <code>lodash</code> 的 <code>import</code> 语句，改为通过插件提供它：</p>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff"><span class="token deleted">- import _ from \'lodash\';</span>\n<span class="token deleted">-</span>\n  function component() {\n    const element = document.createElement(\'div\');\n\n<span class="token deleted">-   // Lodash, now imported by this script</span>\n    element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n<span class="token inserted">+ const webpack = require(\'webpack\');</span>\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    output: {\n      filename: \'bundle.js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n<span class="token inserted">+   plugins: [</span>\n<span class="token inserted">+     new webpack.ProvidePlugin({</span>\n<span class="token inserted">+       _: \'lodash\',</span>\n<span class="token inserted">+     }),</span>\n<span class="token inserted">+   ],</span>\n  };</code></pre>\n<p>我们本质上所做的，就是告诉 webpack……</p>\n<blockquote>\n<p>如果你遇到了至少一处用到 <code>_</code> 变量的模块实例，那请你将 <code>lodash</code> package 引入进来，并将其提供给需要用到它的模块。</p>\n</blockquote>\n<p>运行我们的构建脚本，将会看到同样的输出：</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n    Asset    Size  Chunks                    Chunk Names\nbundle.js  544 kB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  main\n<span class="token punctuation">..</span>.</code></pre>\n<p>还可以使用 <code>ProvidePlugin</code> 暴露出某个模块中单个导出，通过配置一个“数组路径”（例如 <code>[module, child, ...children?]</code>）实现此功能。所以，我们假想如下，无论 <code>join</code> 方法在何处调用，我们都只会获取到 <code>lodash</code> 中提供的 <code>join</code> 方法。</p>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff">  function component() {\n    const element = document.createElement(\'div\');\n\n<span class="token deleted">-   element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');</span>\n<span class="token inserted">+   element.innerHTML = join([\'Hello\', \'webpack\'], \' \');</span>\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const webpack = require(\'webpack\');\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    output: {\n      filename: \'bundle.js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n    plugins: [\n      new webpack.ProvidePlugin({\n<span class="token deleted">-       _: \'lodash\',</span>\n<span class="token inserted">+       join: [\'lodash\', \'join\'],</span>\n      }),\n    ],\n  };</code></pre>\n<p>这样就能很好的与 <a href="/guides/tree-shaking">tree shaking</a> 配合，将 <code>lodash</code> library 中的其余没有用到的导出去除。</p>\n<h2 id="细粒度-shimming">细粒度 Shimming<a href="#%E7%BB%86%E7%B2%92%E5%BA%A6-shimming" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>一些遗留模块依赖的 <code>this</code> 指向的是 <code>window</code> 对象。在接下来的用例中，调整我们的 <code>index.js</code>：</p>\n<pre><code class="hljs language-diff">  function component() {\n    const element = document.createElement(\'div\');\n\n    element.innerHTML = join([\'Hello\', \'webpack\'], \' \');\n<span class="token inserted">+</span>\n<span class="token inserted">+   // 假设我们处于 `window` 上下文</span>\n<span class="token inserted">+   this.alert(\'Hmmm, this probably isn\\\'t a great idea...\')</span>\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<p>当模块运行在 CommonJS 上下文中，这将会变成一个问题，也就是说此时的 <code>this</code> 指向的是 <code>module.exports</code>。在这种情况下，你可以通过使用 <a href="/loaders/imports-loader/"><code>imports-loader</code></a> 覆盖 <code>this</code> 指向：</p>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const webpack = require(\'webpack\');\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    output: {\n      filename: \'bundle.js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n<span class="token inserted">+   module: {</span>\n<span class="token inserted">+     rules: [</span>\n<span class="token inserted">+       {</span>\n<span class="token inserted">+         test: require.resolve(\'./src/index.js\'),</span>\n<span class="token inserted">+         use: \'imports-loader?this=>window\',</span>\n<span class="token inserted">+       },</span>\n<span class="token inserted">+     ],</span>\n<span class="token inserted">+   },</span>\n    plugins: [\n      new webpack.ProvidePlugin({\n        join: [\'lodash\', \'join\'],\n      }),\n    ],\n  };</code></pre>\n<h2 id="全局-exports">全局 Exports<a href="#%E5%85%A8%E5%B1%80-exports" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>让我们假设，某个 library 创建出一个全局变量，它期望 consumer(使用者) 使用这个变量。为此，我们可以在项目配置中，添加一个小模块来演示说明：</p>\n<p><strong>project</strong></p>\n<pre><code class="hljs language-diff">  webpack-demo\n  |- package.json\n  |- webpack.config.js\n  |- /dist\n  |- /src\n    |- index.js\n<span class="token inserted">+   |- globals.js</span>\n  |- /node_modules</code></pre>\n<p><strong>src/globals.js</strong></p>\n<pre><code class="hljs language-js"><span class="token keyword">const</span> file <span class="token operator">=</span> <span class="token string">\'blah.txt\'</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> helpers <span class="token operator">=</span> <span class="token punctuation">{</span>\n  test<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'test something\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  parse<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'parse something\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n<p>你可能从来没有在自己的源码中做过这些事情，但是你也许遇到过一个老旧的 library，和上面所展示的代码类似。在这种情况下，我们可以使用 <a href="/loaders/exports-loader/"><code>exports-loader</code></a>，将一个全局变量作为一个普通的模块来导出。例如，为了将 <code>file</code> 导出为 <code>file</code> 以及将 <code>helpers.parse</code> 导出为 <code>parse</code>，做如下调整：</p>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const webpack = require(\'webpack\');\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    output: {\n      filename: \'bundle.js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n    module: {\n      rules: [\n        {\n          test: require.resolve(\'./src/index.js\'),\n          use: \'imports-loader?this=>window\',\n        },\n<span class="token inserted">+       {</span>\n<span class="token inserted">+         test: require.resolve(\'./src/globals.js\'),</span>\n<span class="token inserted">+         use: \'exports-loader?file,parse=helpers.parse\',</span>\n<span class="token inserted">+       },</span>\n      ],\n    },\n    plugins: [\n      new webpack.ProvidePlugin({\n        join: [\'lodash\', \'join\'],\n      }),\n    ],\n  };</code></pre>\n<p>现在，在我们的 entry 入口文件中（即 <code>src/index.js</code>），我们能 <code>import { file, parse } from \'./globals.js\';</code> ，然后一切将顺利运行。</p>\n<h2 id="加载-polyfills">加载 Polyfills<a href="#%E5%8A%A0%E8%BD%BD-polyfills" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>目前为止我们所讨论的所有内容都是处理那些遗留的 package，让我们进入到第二个话题：<strong>polyfill</strong>。</p>\n<p>有很多方法来加载 polyfill。例如，想要引入 <a href="https://babel.docschina.org/docs/en/babel-polyfill/"><code>babel-polyfill</code></a> 我们只需如下操作：</p>\n<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save babel-polyfill</code></pre>\n<p>然后，使用 <code>import</code> 将其引入到我们的主 bundle 文件：</p>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff"><span class="token inserted">+ import \'babel-polyfill\';</span>\n<span class="token inserted">+</span>\n  function component() {\n    const element = document.createElement(\'div\');\n\n    element.innerHTML = join([\'Hello\', \'webpack\'], \' \');\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<blockquote class="tip">\n<p>注意，我们没有将 <code>import</code> 绑定到某个变量。这是因为 polyfill 直接基于自身执行，并且是在基础代码执行之前，这样通过这些预置，我们就可以假定已经具有某些原生功能。</p>\n</blockquote>\n<p>注意，这种方式优先考虑正确性，而不考虑 bundle 体积大小。为了安全和可靠，polyfill/shim 必须<strong>运行于所有其他代码之前</strong>，而且需要同步加载，或者说，需要在所有 polyfill/shim 加载之后，再去加载所有应用程序代码。\n社区中存在许多误解，即现代浏览器“不需要”polyfill，或者 polyfill/shim 仅用于添加缺失功能 - 实际上，它们通常用于<em>修复损坏实现(repair broken implementation)</em>，即使是在最现代的浏览器中，也会出现这种情况。\n因此，最佳实践仍然是，不加选择地和同步地加载所有 polyfill/shim，尽管这会导致额外的 bundle 体积成本。</p>\n<p>如果你认为自己已经打消这些顾虑，并且希望承受损坏的风险。那么接下来的这件事情，可能是你应该要做的：\n我们将会把 <code>import</code> 放入一个新文件，并加入 <a href="https://github.com/github/fetch"><code>whatwg-fetch</code></a> polyfill：</p>\n<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save whatwg-fetch</code></pre>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff"><span class="token deleted">- import \'babel-polyfill\';</span>\n<span class="token deleted">-</span>\n  function component() {\n    const element = document.createElement(\'div\');\n\n    element.innerHTML = join([\'Hello\', \'webpack\'], \' \');\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<p><strong>project</strong></p>\n<pre><code class="hljs language-diff">  webpack-demo\n  |- package.json\n  |- webpack.config.js\n  |- /dist\n  |- /src\n    |- index.js\n    |- globals.js\n<span class="token inserted">+   |- polyfills.js</span>\n  |- /node_modules</code></pre>\n<p><strong>src/polyfills.js</strong></p>\n<pre><code class="hljs language-javascript"><span class="token keyword">import</span> <span class="token string">\'babel-polyfill\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'whatwg-fetch\'</span><span class="token punctuation">;</span></code></pre>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const webpack = require(\'webpack\');\n\n  module.exports = {\n<span class="token deleted">-   entry: \'./src/index.js\',</span>\n<span class="token inserted">+   entry: {</span>\n<span class="token inserted">+     polyfills: \'./src/polyfills.js\',</span>\n<span class="token inserted">+     index: \'./src/index.js\',</span>\n<span class="token inserted">+   },</span>\n    output: {\n<span class="token deleted">-     filename: \'bundle.js\',</span>\n<span class="token inserted">+     filename: \'[name].bundle.js\',</span>\n      path: path.resolve(__dirname, \'dist\'),\n    },\n    module: {\n      rules: [\n        {\n          test: require.resolve(\'./src/index.js\'),\n          use: \'imports-loader?this=>window\',\n        },\n        {\n          test: require.resolve(\'./src/globals.js\'),\n          use: \'exports-loader?file,parse=helpers.parse\',\n        },\n      ],\n    },\n    plugins: [\n      new webpack.ProvidePlugin({\n        join: [\'lodash\', \'join\'],\n      }),\n    ],\n  };</code></pre>\n<p>如上配置之后，我们可以在代码中添加一些逻辑，有条件地加载新的 <code>polyfills.bundle.js</code> 文件。根据需要支持的技术和浏览器来决定是否加载。我们将做一些简单的试验，来确定是否需要引入这些 polyfill：</p>\n<p><strong>dist/index.html</strong></p>\n<pre><code class="hljs language-diff">  &#x3C;!doctype html>\n  &#x3C;html>\n    &#x3C;head>\n      &#x3C;title>Getting Started&#x3C;/title>\n<span class="token inserted">+     &#x3C;script></span>\n<span class="token inserted">+       const modernBrowser = (</span>\n<span class="token inserted">+         \'fetch\' in window &#x26;&#x26;</span>\n<span class="token inserted">+         \'assign\' in Object</span>\n<span class="token inserted">+       );</span>\n<span class="token inserted">+</span>\n<span class="token inserted">+       if ( !modernBrowser ) {</span>\n<span class="token inserted">+         const scriptElement = document.createElement(\'script\');</span>\n<span class="token inserted">+</span>\n<span class="token inserted">+         scriptElement.async = false;</span>\n<span class="token inserted">+         scriptElement.src = \'/polyfills.bundle.js\';</span>\n<span class="token inserted">+         document.head.appendChild(scriptElement);</span>\n<span class="token inserted">+       }</span>\n<span class="token inserted">+     &#x3C;/script></span>\n    &#x3C;/head>\n    &#x3C;body>\n      &#x3C;script src="index.bundle.js">&#x3C;/script>\n    &#x3C;/body>\n  &#x3C;/html></code></pre>\n<p>现在，在 entry 入口文件中，可以通过 <code>fetch</code> 获取一些数据：</p>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff">  function component() {\n    const element = document.createElement(\'div\');\n\n    element.innerHTML = join([\'Hello\', \'webpack\'], \' \');\n\n    return element;\n  }\n\n  document.body.appendChild(component());\n<span class="token inserted">+</span>\n<span class="token inserted">+ fetch(\'https://jsonplaceholder.typicode.com/users\')</span>\n<span class="token inserted">+   .then(response => response.json())</span>\n<span class="token inserted">+   .then(json => {</span>\n<span class="token inserted">+     console.log(\'We retrieved some data! AND we\\\'re confident it will work on a variety of browser distributions.\')</span>\n<span class="token inserted">+     console.log(json)</span>\n<span class="token inserted">+   })</span>\n<span class="token inserted">+   .catch(error => console.error(\'Something went wrong when fetching this data: \', error))</span></code></pre>\n<p>执行构建脚本，可以看到，浏览器发送了额外的 <code>polyfills.bundle.js</code> 文件请求，然后所有代码顺利执行。注意，以上的这些设定可能还会有所改进，这里我们向你提供一个很棒的想法：将 polyfill 提供给需要引入它的用户。</p>\n<h2 id="进一步优化">进一步优化<a href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p><code>babel-preset-env</code> package 通过 <a href="https://github.com/browserslist/browserslist">browserslist</a> 来转译那些你浏览器中不支持的特性。这个 preset 使用 <a href="https://babel.docschina.org/docs/en/babel-preset-env#usebuiltins"><code>useBuiltIns</code></a> 选项，默认值是 <code>false</code>，这种方式可以将全局 <code>babel-polyfill</code> 导入，改进为更细粒度的 <code>import</code> 格式：</p>\n<pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">\'core-js/modules/es7.string.pad-start\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'core-js/modules/es7.string.pad-end\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'core-js/modules/web.timers\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'core-js/modules/web.immediate\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'core-js/modules/web.dom.iterable\'</span><span class="token punctuation">;</span></code></pre>\n<p>See <a href="https://babeljs.io/docs/en/babel-preset-env">the babel-preset-env documentation</a> for more information.</p>\n<h2 id="node-内置">Node 内置<a href="#node-%E5%86%85%E7%BD%AE" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>像 <code>process</code> 这种 Node 内置模块，能直接根据配置文件进行正确的 polyfill，而不需要任何特定的 loader 或者 plugin。查看 <a href="/configuration/node">node</a> 配置页面获取更多信息。</p>\n<h2 id="其他工具">其他工具<a href="#%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>还有一些其他的工具，也能够帮助我们处理这些遗留模块。</p>\n<p>如果这些遗留模块没有 AMD/CommonJS 版本，但你也想将他们加入 <code>dist</code> 文件，则可以使用 <a href="/configuration/module/#modulenoparse"><code>noParse</code></a> 来标识出这个模块。这样就能使 webpack 将引入这些模块，但是不进行转化(parse)，以及不解析(resolve) <code>require()</code> 和 <code>import</code> 语句。这种用法还会提高构建性能。</p>\n<blockquote class="warning">\n<p>任何需要 AST 的功能（例如 <code>ProvidePlugin</code>）都不起作用。</p>\n</blockquote>\n<p>最后，一些模块支持多种 <a href="/concepts/modules">模块格式</a>，例如一个混合有 AMD、CommonJS 和 legacy(遗留) 的模块。在大多数这样的模块中，会首先检查 <code>define</code>，然后使用一些怪异代码导出一些属性。在这些情况下，可以通过 <a href="/loaders/imports-loader/"><code>imports-loader</code></a> 设置 <code>define=>false</code> 来强制 CommonJS 路径。</p>\n<hr>\n<blockquote class="tip">\n<p>译者注：shimming 是一个库(library)，它将一个新的 API 引入到一个旧的环境中，而且仅靠旧的环境中已有的手段实现。polyfill 就是一个用在浏览器 API 上的 shimming。我们通常的做法是先检查当前浏览器是否支持某个 API，如果不支持的话就按需加载对应的 polyfill。然后新旧浏览器就都可以使用这个 API 了。</p>\n</blockquote>\n'}}]);